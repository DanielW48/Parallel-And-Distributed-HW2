## Problem 1
We will implement the strategy similar to that of the one we went over with the room and the switch in class.

We will assign the task of "counting" the number of people who have certainly visited the labyrinth to the first thread. All other threads besides the first thread will follow the following procedure: when they enter the labyrinth, if and only if this is their first time seeing a cupcake at the end of the labyrinth, they will eat it and leave the spot empty. Otherwise they will leave it the way they found it. If they show up for the first few times and there is no cupcake, then they will leave the spot be. Also if they show up and there is a cupcake but they have already eaten one before, they will leave the cupcake there for someone else to find.

The process of the first thread will be as follows: if they get to the end of the labyrinth and there is no cupcake in the spot, then they will add one to their mental counter, request a new cupcake be placed, leave it alone, and leave. Otherwise, they will leave it the way they found it. When the first thread's mental counter reaches exactly N - 1, then he knows we are done and can alert the minotaur.

This process ensures that each person that eats a cupcake for their first time is correctly counted exactly once by the first thread. Since each person only eats at most one cupcake, then all N - 1 in the first thread's mental counter represent N - 1 different and distinct people that have already visited the labyrinth, the first thread can be sure that everyone has been at least once. When N is greater than 1, we know that in order for the counter to reach N - 1, the first thread will have to have visited the labyrinth at least once to change the counter from 0.

This strategy fails when N is exactly equal to 1, but a simpler strategy can be crafted for a case like this, in which the first thread would alert the minotaur after his first visit to the labyrinth.

In the code, we use a condition_variable and a mutex to alert threads of when they should be running certain processes. The minotaur will continue to assign random turns to people, perhaps the same people and in any order. This will be represented by the main thread. This thread will use a condition_variable to wait for the condition that the current turn variable will be reset to -1. Then it will assign a current turn, change its value, and notify all other threads to check to see if it is their turn. For the other threads, their process will be to continuously wait for their turn or until the game has finished using a similar conditon_variable. when it is their turn, they will run their procedure, then reset the current turn variable to -1 (perhaps also set a flag to signal that the game is over if this thread is the first thread), and then notify all other threads of the changes.


## Problem 2
The first strategy is good in the fact that no thread is responsible for anything but themselves, but is bad in the fact that it has to continuously check to see if the showroom is available, and perhaps spend CPU time doing so. The other disadvantage to this strategy is that there is no consistency to which threads must wait to enter the showroom. Some may show up early and find a full showroom and not return to check until much later, while another thread may show up just after this thread and find it empty and "skip" them.

The second strategy is slightly better than the first as guests do not have to go all the way to the showroom to check if it is available and waste valuable resources doing so, rather they can perform a simple check of the sign. The disadvantage to this strategy is there is no organization for who should enter when, resulting in the same problem as the first strategy where some threads might get "skipped".

The third strategy resolves the organization issue by introducing the queue. Now the threads can do whatever they would like to while they are waiting, and then when it is their turn in the queue, they can go to the showroom and check it out. The downside to this is now each thread has a responsibility to alert the next thread in line, adding complexity to their processes.

In the code, we use a condition_variable and mutex at multiple places again to help notify threads of when it is their turn. The process for the main thread will be to generate a large queue of turns for showroom visits and then wait for everyone in the queue to have taken their turn. This waiting will be done with a condition_variable. The process for the other threads will be to wait for it to be their turn or until everyone in the queue has gone using a condition_variable again. Once it is their turn, they will enter the showroom, check out the vase, and then either set the current turn to -1 if they are last in the queue, or set the current turn to be the next guy in the queue. Then they will notify the other threads of the changes that were made accordingly.
